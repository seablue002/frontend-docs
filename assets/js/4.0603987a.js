(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{280:function(t,e,a){t.exports=a.p+"assets/img/2023-04-13142140.56d1c56a.png"},281:function(t,e,a){t.exports=a.p+"assets/img/2023-04-13142812.f4c9eda2.png"},282:function(t,e,a){t.exports=a.p+"assets/img/2023-04-13142958.9ba01864.png"},283:function(t,e,a){t.exports=a.p+"assets/img/57010188-fae2b380-6c2d-11e9-974e-6d2cb4eee219.a1bf4981.png"},284:function(t,e,a){t.exports=a.p+"assets/img/v2-63836b16b00a761dc0b0bb2cbea472a3_720w.a597e68e.jpg"},285:function(t,e,a){t.exports=a.p+"assets/img/v2-5b9d3be53ba6abb281d4f29897bbe16a_720w.b6ded9ae.jpg"},286:function(t,e,a){t.exports=a.p+"assets/img/2d81e368b194463aa99adeaee2994fb8.154f2b3a.png"},287:function(t,e,a){t.exports=a.p+"assets/img/3e7ec6543e4044a1a19ba6736090e832.b413c2d6.jpeg"},317:function(t,e,a){"use strict";a.r(e);var r=a(14),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"http与浏览器知识点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http与浏览器知识点"}},[t._v("#")]),t._v(" Http与浏览器知识点")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("涉及内容")]),t._v(" "),e("p",[t._v("包含Http相关的中高级知识点，以及疑难点。")])]),t._v(" "),e("h2",{attrs:{id:"_1、强缓存、协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、强缓存、协商缓存"}},[t._v("#")]),t._v(" 1、强缓存、协商缓存 "),e("Badge",{attrs:{text:"中级",type:"warning"}})],1),t._v(" "),e("p",[t._v("缓存：浏览器与服务器配合，根据设置相应的缓存header头信息字段来控制如何是否缓存与如何控制缓存读取流程。\n如果开启缓存，服务器上的资源文件会在被浏览器初次请求时被缓存下来，在内存与本地磁盘，以便后续的请求加速。")]),t._v(" "),e("p",[t._v("整个 Web 系统架构在 HTTP 协议 之上， 利用 HTTP 的缓存机制不仅可以极大地减少服务器负载， 更重要的是加速页面的载入，以及减少用户的流量消耗。 快速到达和易于访问是 Web 与生俱来的特性， 其缓存机制也早已被服务器和浏览器厂商广泛地实现， 我们作为 Web 内容的作者何乐而不为呢？\nWeb 服务器（比如 Tomcat、Apache、Virgo）或服务器端框架（比如 Django、Express.js） 都会实现 HTTP 缓存机制")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching",target:"_blank",rel:"noopener noreferrer"}},[t._v("缓存MDN"),e("OutboundLink")],1),t._v("使用分为两个阶段（1.强缓存、2.协商缓存），如果浏览器缓存可用（开启了浏览器缓存、缓存未失效）则直接从浏览器缓存读取，\n读取浏览器缓存也分为两个步骤：如果cache内存中有缓存直接读内存缓存，否则看磁盘是否有缓存，有则读取磁盘缓存，否则发送请求到服务器，根据服务器")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/551365386",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考1"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://www.jianshu.com/p/7bc3b8983c51",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考2"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://blog.csdn.net/GreekMrzzJ/article/details/89738573",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考3"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://www.jianshu.com/p/a68e05fe0185",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考4"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("关键词："),e("code",[t._v("Cache-Control")]),t._v("、"),e("code",[t._v("Etag")]),t._v("搭配"),e("code",[t._v("If-None-Match")]),t._v("（request header字段If-None-Match取值自上次response header中的Etag值）、"),e("code",[t._v("Last-Modify")]),t._v("搭配"),e("code",[t._v("If-Modify-Since")]),t._v("（request header字段If-Modify-Since取值自上次response header中的Last-Modify值）")]),t._v(" "),e("p",[t._v("Expires")]),t._v(" "),e("p",[t._v("Cache-Control 响应头表示了资源是否可以被缓存，以及缓存的有效期。")]),t._v(" "),e("p",[t._v("Etag 响应头标识了资源的版本，此后浏览器可据此进行缓存以及询问服务器。")]),t._v(" "),e("p",[t._v("Last-Modified 响应头标识了资源的修改时间，此后浏览器可据此进行缓存以及询问服务器。")]),t._v(" "),e("h3",{attrs:{id:"_1-强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-强缓存"}},[t._v("#")]),t._v(" 1.强缓存")]),t._v(" "),e("p",[t._v("强缓存就是在有效期内不发送请求直接本地读缓存数据")]),t._v(" "),e("p",[t._v("浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK\n"),e("img",{attrs:{src:a(280),alt:"2023-04-13142140.png"}}),t._v(" "),e("img",{attrs:{src:a(281),alt:"2023-04-13142812.png"}}),t._v(" "),e("img",{attrs:{src:a(282),alt:"2023-04-13142958.png"}})]),t._v(" "),e("p",[t._v("Expires：值为绝对时间，不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1")]),t._v(" "),e("p",[t._v("Cache-Control：值为相对时间，如果与Expires同时设置的话，其优先级高于Expires。")]),t._v(" "),e("p",[t._v("cache-control有下面几个比较常用的设置值：")]),t._v(" "),e("p",[t._v("-max-age：设置失效时间，客户端在这个有效期内，如果又请求该资源，就直接读取缓存")]),t._v(" "),e("p",[t._v("-no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则从缓存中取数据")]),t._v(" "),e("p",[t._v("-no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求。")]),t._v(" "),e("p",[t._v("-public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。")]),t._v(" "),e("p",[t._v("-private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存")]),t._v(" "),e("h3",{attrs:{id:"_2-协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-协商缓存"}},[t._v("#")]),t._v(" 2.协商缓存")]),t._v(" "),e("p",[t._v("协商缓存就是发送请求给服务器由服务器比对相关控制缓存的header字段决定是让浏览器继续读缓存还是从服务器重新返回数据")]),t._v(" "),e("p",[t._v("Last-Modify搭配If-Modify-Since：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值服务端header中返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存")]),t._v(" "),e("p",[t._v("Etag搭配If-None-Match：web服务器响应请求时，会在header中加一个Etag用来告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后将If-None-Match与Etag进行比对，决定是否命中协商缓存；\n"),e("img",{attrs:{src:a(283),alt:"57010188-fae2b380-6c2d-11e9-974e-6d2cb4eee219.png"}})]),t._v(" "),e("p",[t._v("ETag和Last-Modified的作用和用法，他们的区别：")]),t._v(" "),e("p",[t._v("1.Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；")]),t._v(" "),e("p",[t._v("2.在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；")]),t._v(" "),e("p",[t._v("3.在优先级上，服务器校验优先考虑Etag。")]),t._v(" "),e("p",[t._v("缓存控制字段优先级： "),e("mark",[t._v("Cache-Control  > expires > Etag > Last-Modified")])]),t._v(" "),e("h3",{attrs:{id:"_3-浏览器缓存过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-浏览器缓存过程"}},[t._v("#")]),t._v(" 3.浏览器缓存过程")]),t._v(" "),e("p",[t._v("1.浏览器第一次请求资源，服务器返回200，并把资源上次修改时间和资源的唯一标识写在response header中，浏览器将资源文件从服务器上请求下载下来")]),t._v(" "),e("p",[e("img",{attrs:{src:a(284),alt:"v2-63836b16b00a761dc0b0bb2cbea472a3_720w.jpg"}})]),t._v(" "),e("p",[t._v("2.下一次请求，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match（取值自上次response header中的Etag值）和If-Modified-Since（取值自上次response header中的Last-Modify值）的请求")]),t._v(" "),e("p",[e("img",{attrs:{src:a(285),alt:"v2-5b9d3be53ba6abb281d4f29897bbe16a_720w.jpg"}})]),t._v(" "),e("p",[t._v("3.服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；")]),t._v(" "),e("p",[t._v("4.如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；")]),t._v(" "),e("h3",{attrs:{id:"_4-前端设置html页面缓存方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-前端设置html页面缓存方法"}},[t._v("#")]),t._v(" 4.前端设置html页面缓存方法")]),t._v(" "),e("p",[t._v("通过HTTP的META设置expires和cache-control")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("code 查看代码")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("http-equiv")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("Cache-Control"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("content")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("max-age=7200"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("http-equiv")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("Expires"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("content")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("Mon, 20 Jul 2013 23:00:00 GMT"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])])])]),t._v(" "),e("h3",{attrs:{id:"_5-后端设置缓存控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-后端设置缓存控制"}},[t._v("#")]),t._v(" 5.后端设置缓存控制")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6844903512761974797",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用HTTP缓存"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"_6-浏览器刷新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-浏览器刷新"}},[t._v("#")]),t._v(" 6.浏览器刷新")]),t._v(" "),e("p",[t._v("正常重新加载\n按下刷新按钮或快捷键（在 MacOS 中是 Cmd+R）会触发浏览器的“正常重新加载”（normal reload）， 此时浏览器会执行一次 Conditional GET。 Cache-Control 等缓存头字段会被忽略，并且带If-None-Match, If-Modified-Since等头字段。\n此时服务器总会收到一次 HTTP GET 请求。 在 Chrome 中按下刷新，浏览器还会带如下请求头：")]),t._v(" "),e("p",[t._v("Cache-Control:max-age=0")]),t._v(" "),e("p",[t._v("强制重新加载")]),t._v(" "),e("p",[t._v("在 Chrome 中按下 Cmd+Shift+R （MacOS）可以触发强制重新加载（Hard Reload）， 此时包括页面本身在内的所有资源都不会使用缓存。 浏览器直接发送 HTTP 请求且不带任何条件请求字段。")]),t._v(" "),e("h2",{attrs:{id:"_2、重排-回流-reflow、重绘repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、重排-回流-reflow、重绘repaint"}},[t._v("#")]),t._v(" 2、重排（回流）Reflow、重绘Repaint "),e("Badge",{attrs:{text:"中级",type:"warning"}})],1),t._v(" "),e("h3",{attrs:{id:"_1、重排-回流-reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、重排-回流-reflow"}},[t._v("#")]),t._v(" 1、重排（回流）Reflow")]),t._v(" "),e("p",[t._v("当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。\n重排也叫回流，简单的说就是重新生成布局，重新排列元素。")]),t._v(" "),e("p",[t._v("触发重排的场景")]),t._v(" "),e("ul",[e("li",[t._v("页面初始渲染，这是开销最大的一次重排；")]),t._v(" "),e("li",[t._v("添加/删除可见的DOM元素；")]),t._v(" "),e("li",[t._v("改变元素位置；")]),t._v(" "),e("li",[t._v("改变元素尺寸，比如边距、填充、边框、宽度和高度等；")]),t._v(" "),e("li",[t._v("改变元素内容，比如文字数量，图片大小等；")]),t._v(" "),e("li",[t._v("改变元素字体大小；")]),t._v(" "),e("li",[t._v("改变浏览器窗口尺寸，比如resize事件发生时；")]),t._v(" "),e("li",[t._v("激活CSS伪类（例如：:hover）；")]),t._v(" "),e("li",[t._v("设置 style 属性的值，因为通过设置style属性改变结点样式的话（频繁设置属性不会每次都会重排，浏览做了相应的渲染队列优化）；")]),t._v(" "),e("li",[t._v("查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。（查询属性和调用计算方法每次都会触发重排）")])]),t._v(" "),e("h3",{attrs:{id:"_2、重绘-repaints"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、重绘-repaints"}},[t._v("#")]),t._v(" 2、重绘(Repaints)")]),t._v(" "),e("p",[t._v("当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。")]),t._v(" "),e("p",[t._v("触发重绘的场景")]),t._v(" "),e("ul",[e("li",[t._v("设置元素的透明度；")]),t._v(" "),e("li",[t._v("设置元素的背景色，字体颜色；")]),t._v(" "),e("li",[t._v("设置元素的可见性。")])]),t._v(" "),e("h3",{attrs:{id:"_3、优化建议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、优化建议"}},[t._v("#")]),t._v(" 3、优化建议")]),t._v(" "),e("p",[t._v("重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。")]),t._v(" "),e("ul",[e("li",[t._v("减少重排范围\n当重排无可避免时，尽量避免全局范围的重排，进行局部范围的重排，尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。")])]),t._v(" "),e("p",[t._v("尽可能在低层级的DOM节点上进行修改，避免通过父元素修改改变内部元素。")]),t._v(" "),e("p",[t._v("不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("减少重排次数\n样式集中改变，通过更改类名而不是直接修改样式或设置属性。")])]),t._v(" "),e("li",[e("p",[t._v("分离读写操作（合并读写操作）\n分离读写操作，DOM 的多个读操作（或多个写操作），应该放在一起。不要读、写操作混在一起写。（这样多个写操作只会触发一次重排）")])])]),t._v(" "),e("p",[t._v("将 DOM 离线")]),t._v(" "),e("p",[t._v("使用 display:none，元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 display属性显示（另一次重排重绘），这样多次的重排重绘缩减成两次而已。")]),t._v(" "),e("p",[t._v("通过 documentFragment 创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。")]),t._v(" "),e("p",[t._v("复制节点，在副本上工作，然后替换相应节点。")]),t._v(" "),e("ul",[e("li",[t._v("使用 absolute 或 fixed 布局，使它脱离文档流，避免引起父元素及后续元素大量的回流。")]),t._v(" "),e("li",[t._v("缓存布局信息。")]),t._v(" "),e("li",[t._v("优化动画\n把动画效果应用到 position属性为 absolute 或 fixed 的元素上，这样对其他元素影响较小，其次减少相应动画流畅性，否则Layout就会过于频繁，大量消耗CPU资源。")])]),t._v(" "),e("p",[t._v("启用GPU加速GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/baidu_38242832/article/details/117339142",target:"_blank",rel:"noopener noreferrer"}},[t._v("参照"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_3-tcp连接三次握手的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-tcp连接三次握手的过程"}},[t._v("#")]),t._v(" 3. TCP连接三次握手的过程  "),e("Badge",{attrs:{text:"初级",type:"tip"}})],1),t._v(" "),e("ul",[e("li",[t._v("第一次")])]),t._v(" "),e("p",[t._v("第一次握手：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。")]),t._v(" "),e("ul",[e("li",[t._v("第二次")])]),t._v(" "),e("p",[t._v("第二次握手：服务器收到syn包，必须确认客户端的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。")]),t._v(" "),e("ul",[e("li",[t._v("第三次")])]),t._v(" "),e("p",[t._v("第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。")]),t._v(" "),e("h2",{attrs:{id:"_4、浏览器渲染机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、浏览器渲染机制"}},[t._v("#")]),t._v(" 4、浏览器渲染机制 "),e("Badge",{attrs:{text:"中级",type:"warning"}})],1),t._v(" "),e("p",[e("img",{attrs:{src:a(286),alt:"2d81e368b194463aa99adeaee2994fb8.png"}}),t._v(" "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器的工作原理"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_5、从输入url到页面渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、从输入url到页面渲染"}},[t._v("#")]),t._v(" 5、从输入URL到页面渲染  "),e("Badge",{attrs:{text:"中级",type:"warning"}})],1),t._v(" "),e("p",[t._v("DNS解析-》三次握手建立tcp连接-》客户端发送HTPP请求-》服务器处理请求响应返回数据-》渲染（dom+cssom=>render tree=>layout=>padinting）=>四次挥手")]),t._v(" "),e("h2",{attrs:{id:"_6、tcp、udp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、tcp、udp"}},[t._v("#")]),t._v(" 6、TCP、UDP  "),e("Badge",{attrs:{text:"中级",type:"warning"}})],1),t._v(" "),e("p",[e("a",{attrs:{href:"https://baijiahao.baidu.com/s?id=1693383134922615393&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"}},[t._v("参照"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_7-http-状态码-http-status-code-的含义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-http-状态码-http-status-code-的含义"}},[t._v("#")]),t._v(" 7. HTTP 状态码（HTTP Status Code）的含义  "),e("Badge",{attrs:{text:"初级",type:"tip"}})],1),t._v(" "),e("p",[t._v("HTTP 304，有时也称为“304 Not Modified”，是一种与浏览器通信的代码：“自上次访问以来，请求的资源未被修改。”本质上，服务器告诉您的浏览器，自您最近一次访问该页面以来，浏览器中存储（缓存）的资源没有被修改。反过来，您的浏览器会从缓存中检索网页的保存版本。这样做的目的是通过防止浏览器重复下载相同的信息来提高页面速度和交付。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("200 OK\n请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。")])]),t._v(" "),e("li",[e("p",[t._v("301 Moved Permanently\n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。")])]),t._v(" "),e("li",[e("p",[t._v("302 Move Temporarily\n请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。")])]),t._v(" "),e("li",[e("p",[t._v("304 Not Modified\n如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。")])]),t._v(" "),e("li",[e("p",[t._v("400  Bad Request\n1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。")])])]),t._v(" "),e("p",[t._v("2、请求参数有误。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("401  Unauthorized\n当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。")])]),t._v(" "),e("li",[e("p",[t._v("403  Forbidden\n服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。")])]),t._v(" "),e("li",[e("p",[t._v("404 Not Found\n请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。")])]),t._v(" "),e("li",[e("p",[t._v("500 Internal Server Error\n服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。")])]),t._v(" "),e("li",[e("p",[t._v("502 Bad Gateway\n作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。")])]),t._v(" "),e("li",[e("p",[t._v("504 Gateway Timeout\n作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。")])])]),t._v(" "),e("h2",{attrs:{id:"_8-uri与urn、url"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-uri与urn、url"}},[t._v("#")]),t._v(" 8. URI与URN、URL  "),e("Badge",{attrs:{text:"初级",type:"tip"}})],1),t._v(" "),e("p",[t._v("URI（统一资源标识符）是一个指向资源的字符串。最通常用在 URL 上来指定 Web 上资源文件的具体位置。相比之下，URN 是在给定的命名空间用名字指向具体的资源，如：书本的 ISBN。")]),t._v(" "),e("ul",[e("li",[t._v("URI = Uniform Resource Identifier 统一资源标志符")]),t._v(" "),e("li",[t._v("URL = Uniform Resource Locator 统一资源定位符")]),t._v(" "),e("li",[t._v("URN = Uniform Resource Name 统一资源名称")])]),t._v(" "),e("p",[t._v("大白话，就是URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI，本来设想的的使用两种方法定位：1，URL，用地址定位；2，URN 用名称定位。")]),t._v(" "),e("p",[t._v("举个例子：去村子找个具体的人（URI），如果用地址：某村多少号房子第几间房的主人 就是URL， 如果用身份证号+名字 去找就是URN了。")]),t._v(" "),e("p",[t._v("结果就是 目前WEB上就URL流行开了，平常见得URI 基本都是URL。")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/URI",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考1-mdn"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://www.zhihu.com/question/21950864",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考2-知乎"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_9-七层网络模型与各层协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-七层网络模型与各层协议"}},[t._v("#")]),t._v(" 9. 七层网络模型与各层协议  "),e("Badge",{attrs:{text:"初级",type:"tip"}})],1),t._v(" "),e("p",[t._v("互联网的本质就是一系列的网络协议，这个协议就叫OSI协议（一系列协议），按照功能不同，分工不同，人为的分层七层。实际上这个七层是不存在的。没有这七层的概念，只是人为的划分而已。区分出来的目的只是让你明白哪一层是干什么用的。")]),t._v(" "),e("p",[t._v("每一层都运行不同的协议。协议是干什么的，协议就是标准。")]),t._v(" "),e("p",[t._v("实际上还有人把它划成五层、四层。")]),t._v(" "),e("p",[t._v("七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。")]),t._v(" "),e("p",[t._v("五层划分为：应用层、传输层、网络层、数据链路层、物理层。")]),t._v(" "),e("p",[t._v("四层划分为：应用层、传输层、网络层、网络接口层。\n"),e("img",{attrs:{src:a(287),alt:"3e7ec6543e4044a1a19ba6736090e832.jpeg"}}),t._v(" "),e("a",{attrs:{href:"https://blog.csdn.net/xiaojin21cen/article/details/88237826",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考1"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_10-tcp-ip协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-tcp-ip协议"}},[t._v("#")]),t._v(" 10. TCP/IP协议  "),e("Badge",{attrs:{text:"初级",type:"tip"}})],1),t._v(" "),e("p",[e("a",{attrs:{href:"https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE/212915?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP/IP协议"),e("OutboundLink")],1),t._v("（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。")]),t._v(" "),e("p",[t._v("TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。")]),t._v(" "),e("h2",{attrs:{id:"_11-前端性能优化方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-前端性能优化方案"}},[t._v("#")]),t._v(" 11. 前端性能优化方案 "),e("Badge",{attrs:{text:"高级",type:"error"}})],1),t._v(" "),e("p",[t._v("前端优化主要从两方面入手，1、减少请求时间（合并请求、减少文件体积）、2、优化加快响应速度")]),t._v(" "),e("p",[t._v("对应的具体实现、实施方案为：\nCDN减少代码体积、懒加载、代码压缩gzip，雅虎军规")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/knowledge/http.html#_1、强缓存、协商缓存"}},[t._v("HTTP缓存")]),t._v("，Web 性能优化还有很多其他途径，比如 预加载和预渲染、"),e("RouterLink",{attrs:{to:"/knowledge/javascript.html#_9-script-标签执行与加载时机-defer、async-和防阻塞方法"}},[t._v("脚本异步载入async、defer")]),t._v(" 等")],1),t._v(" "),e("p",[t._v("dom操作合并，缓存dom，清除无效dom引用、减少重排、事件防抖节流")]),t._v(" "),e("p",[t._v("webpack打包优化 tree shaking、 代码分割code-spliting")]),t._v(" "),e("p",[t._v("前端性能优化的七大手段，包括减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化\n"),e("a",{attrs:{href:"https://www.cnblogs.com/xiaohuochai/p/9178390.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考1"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_12-get、post请求的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-get、post请求的区别"}},[t._v("#")]),t._v(" 12. get、post请求的区别 "),e("Badge",{attrs:{text:"初级",type:"tip"}})],1),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.zhihu.com/question/28586791",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考1"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考2"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_13-简单请求、复杂请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-简单请求、复杂请求"}},[t._v("#")]),t._v(" 13. 简单请求、复杂请求 "),e("Badge",{attrs:{text:"初级",type:"tip"}})],1),t._v(" "),e("h3",{attrs:{id:"_1、简单请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、简单请求"}},[t._v("#")]),t._v(" 1、简单请求")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("简单请求方法\n"),e("code",[t._v("get")]),t._v("、"),e("code",[t._v("post")]),t._v("、"),e("code",[t._v("head")])])]),t._v(" "),e("li",[e("p",[t._v("简单请求只能包含简单头部\n"),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header",target:"_blank",rel:"noopener noreferrer"}},[t._v("简单头部"),e("OutboundLink")],1),t._v("可以是这些字段\n"),e("code",[t._v("Accept")]),t._v(",\n"),e("code",[t._v("Accept-Language")]),t._v(",\n"),e("code",[t._v("Content-Language")]),t._v(",\n"),e("code",[t._v("Content-Type")]),t._v("并且值是 application/x-www-form-urlencoded, multipart/form-data, 或者 text/plain之一的（忽略参数）.")])])]),t._v(" "),e("p",[t._v("或者以下客户端头部之一的也可以被认为是简单头部："),e("code",[t._v("DPR")]),t._v(", "),e("code",[t._v("Downlink")]),t._v(", "),e("code",[t._v("Save-Data")]),t._v(", "),e("code",[t._v("Viewport-Width")]),t._v(", "),e("code",[t._v("Width")])]),t._v(" "),e("ul",[e("li",[t._v("如果是 post 请求，content-type 只能是以下三种类型 "),e("code",[t._v("text/plain")]),t._v(", "),e("code",[t._v("multipart/form-data")]),t._v(", "),e("code",[t._v("application/x-www-form-urlencoded")])])]),t._v(" "),e("h3",{attrs:{id:"_2、-复杂请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、-复杂请求"}},[t._v("#")]),t._v(" 2、 复杂请求")]),t._v(" "),e("p",[t._v("非简单请求的其他请求类型： 如 put, delete, patch\n还有，不满足简单请求的三个条件任意一种的情形")]),t._v(" "),e("h3",{attrs:{id:"_3、预检请求-options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、预检请求-options"}},[t._v("#")]),t._v(" 3、预检请求 options")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/Preflight_request",target:"_blank",rel:"noopener noreferrer"}},[t._v("预检请求 Preflight request"),e("OutboundLink")],1),t._v("就是，当客户端发起 复杂请求，可能会有 cors （跨域问题）， 预检请求就会先去探探路。这也就是，为什么每次 发起 复杂请求，检查元素中的 network 会有两个请求，一次是 options, 一次是真正的 复杂请求。")]),t._v(" "),e("p",[t._v("它一般是用了以下几个 HTTP 请求首部的 OPTIONS 请求：Access-Control-Request-Method 和 Access-Control-Request-Headers，以及一个 Origin 首部。")]),t._v(" "),e("p",[t._v("当有必要的时候，浏览器会自动发出一个预检请求；所以在正常情况下，前端开发者不需要自己去发这样的请求。")]),t._v(" "),e("p",[t._v("当 options 请求探路回来，会带着 Access-Control-Allow-Origin, Access-Control-Allow-Methods 其中会显示是否支持发起跨域请求。 如果允许，真正的复杂请求才会发起。\n"),e("a",{attrs:{href:"https://blog.csdn.net/brucehongsen/article/details/120136608",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考1"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"_4、预检请求-options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、预检请求-options"}},[t._v("#")]),t._v(" 4、预检请求 options")]),t._v(" "),e("p",[t._v("fetch请求、"),e("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&mid=2649092047&idx=3&sn=6d91e3e47971dc1e0d8e5422ce33b487&chksm=be5bc862892c4174400e477bdea6dbe7df1eb750e15af3f4a6101657948e3c624674c2af1a07&scene=27",target:"_blank",rel:"noopener noreferrer"}},[t._v("axios请求"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_14、tcp与http请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14、tcp与http请求"}},[t._v("#")]),t._v(" 14、tcp与http请求")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://baijiahao.baidu.com/s?id=1761049607379705379&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"}},[t._v("一个tcp可以发多少个http请求"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);